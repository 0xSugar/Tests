public class NotesSQL {

}

/**
 * Какое-то вступление.
 * @author skul
 */

/*
* Для работы с базой данных нужно пару программ. Минимум это клиент-сервер:
* Клиент - программа, которая посылает запрос в базу данных
* Сервер - программа (PostgreSQL), которая обрабатывает запрос и возвращает результат в виде таблицы
*
* Это минимум для работы. Сервером является Postgre, тогда как клиентом в моем случае - DataGrid Так же можно
* использовать дополнительные программы, к примеру:
* -> pg_ctl (pg_ctlcluster) - используется для запуска, перезапуска и прочей работы сервера
*
*
*
*
*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  *//**
    Создание запроса    *//*
SELECT * FROM mydb WHERE age < 18 ORDER BY first_name, last_name LIMIT 5;
SELECT          команда, выбрать
DISTINCT        - если написать это после select и потом столбец - оно покажет все уникальные значения в столбце
*               из всех колонок (или перечислить через запятую нужные колонки
        name, id        - вывод только этих полей, через запятую
        ROUND(price,1)  - округляет - выводит, с 1й цифрой после зарятов (без цифр - ROUND(price))
            Имя столбца при этом будет называться по имени запроса - ROUND(price,1).. что бы этого не было:
            ROUND(price) as price   - теперь название колонки будет price                              ↓ ↓××
        TRUNCATE(price, 1) as price - не округляет, выводит отбросив все, после 1й цифры после запятой 8.888 -> 8.8
        FLOOR(price) as price       - убирает остаток и выводит нижнее значение 8.7 -> 8 (как TRUNCATE без 1)
        CEILING(price) as price     - тоже саоме, что и FLOOR но выводит верхнее значение 8.7 -> 9, 8.01 -> 9
        Так же сюда можно вставлять математ. функции -> ROUND(amount - (amount * personal_sale / 100)) as amount (считает цену с учтом перс. скидки)
WHERE           команда, по какому условию (OR, AND, IN, BETWEEN)
        AND & OR, дальше идет название колонки и условие, = < > !=.  OR можно заменить на ...
        IN - перечисляем вирианты, что бы не писать (country = 'UA' AND country = 'US')
            WHERE country IN ('ЮА', 'ЮС')..
        BETWEEN - WHERE price BETWEEN 10000 AND 20000 (вместе price > 10000 AND price < 20000) // не знаю на счет, это больше или равно или строго больше...
        Можно комбинировать: SELECT * FROM sqlData WHERE country IN ('UA', 'US') AND age > 18.
ORDER BY        сортировка (для строк - алфавитный порядок)
        first_name - сортировка только по имени в алф. порядке
        first_name, last_name - сортировка по имени сперва, и потом по фамилии (все логично.. если одинаковые имена и разные фамилии - фамилии так же будут отсортированы)
        birthday DESC - сортировка по дате, но с DESC - в обратном порядке
        first_name, birthday SECT - сначала алф порядок имени, потом наоборот дату с большего к меньшему
LIMIT               ограничего на вывод,
        5;          вывод только 5 результатов
        3, 5;       первое число - сколько нужно ПРОПУСТИТЬ, второе - сколько получить. Мы ограничили вывод 5ю
                    товарами и дописали, что первые 3 - пропустить. Т.е. при лимите так же можно пропускать самые
                    верхние варианты и выводить те, что после них... если они есть.. если будет меньше -
                    выдаст 1 или 2.. меньше, но первые 5 - пропустит

LIKE    Select * from table where first_name like "Рука";           будет тоже самое, что =
        Select * from table where first_name like binary "Рука";    с учтом регистра (- psql, + mysql)
            like 'С%';   - покажет всех, что начинается на С
            like '33%2'; - покажет 3322 или 33423412.. т.е. только начало 33 и конец 2, по середине сколько угодно
            % - любое кол-во символов, _ - один символ:
            like '3_'  - покажется только 31, 32, 33.. только 2 цифры
            like '3_2' - только 3?2 - 3 цифры, по середине любая
            not like   - тоже самая логика, но исключение..
            \% - экранирование

CREATE FULLTEXT INDEX our_name ON tableName(column); - создание полнотекстового индекса с именем our_name
        в таблице tableName и колонка - column. Дальше:
SELECT * from table WHERE MATCH (column) AGAINST ('слово которое ищем'); - в данном случае он будет искать в
        колонке column сторки, где есть слова - 'слово', 'которое' и 'ищем'. Ищет слова по отдельности, но отличие
        от like в том, что чем точнее фраза соотвествует - тем выше она будет.. т.е. отсортировано
        Так же можно включить "логичекое определение", т.е. нам будут доступны различные операторы для уточнения
        запроса. Сделать это можно вот так:
        SELECT * from table WHERE MATCH (column) AGAINST ('слово которое ищем' IN BOOLEAN MODE);
            AGAINST ('+слово которое ищем') - уберет все поля, где есть слова 'которое' и 'ищем', но нет 'слово'
                т.е. делает его обязательным
            - обратное, исключает
            ~ обесценивает значимость, т.е. эти результы будут, но после более релевантных
            * продукт* -> продукт, продукты, продуктам | ищет
            "целая фраза" если нужно искать не слова по отдельности, а целую фразу - исп. двойные кавычки "
Удаление:
    Синтаксис такой же, как и SELECT.
    delete from list where country = 'ua' and (age < 18 or age > 30);
    Очистить лист - delete from list; или truncate table list;
    P.S.: ВАЖНО! - сначала через SELECT выбираем данные, смотрим - если все ок, то меняем SELECT на DELETE
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   *//**
    Добавление данных в таблицу    *//*
Синтаксис -> INSERT INTO название_таблицы (столбика_1, столбик_2, и_т_д) VALUES ('значение 1', 30, '<- число без скобок');
Пример:
    INSERT INTO users (first_name, last_name, email, salary) VALUES ('Женько', 'Петков', 'j@gmail.com', 1);
Добавить можно сразу несколько "полей":
Синтаксис -> INSERT INTO название_таблицы (столбик_1, столбик_2)
            VALUES ('значение 1.1', 'значение 1.2'),
                   ('значение 2.1', 'значение 2.2');
Пример:
    INSERT INTO users (name, age) VALUES ('Женько', 18), ('Петько', 20), ('Рудько', 17);

Так же это можно записать другим сопособом, через SET:
Синтаксис -> INSERT INTO название_таблицы SET столбик_1 = someth, столбик_2 = someth;
Пример:
    INSERT INTO users SET first_name = 'Женько', last_name = 'Петков', email = j@gmail.com, salary = 1;
Как логично понятно -> можно создать поле, после чего этой командой присвоить значения.. или изменять.. это мне надо.



P.S.: дата записывается в виде 'гггг-ММ-дд' ('2020-24-04')                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   *//**

    Прочее    *//*
Если идет перечисление, к примеру WHERE id = 3, 4, то это нужно записывать в скобках - WHERE id = (3, 4)
UPDATE - изменить данные в строке, DELETE - полность удалить строку

ENUM - что-то одно, в примере status enum ('new', 'confirmed', 'cancelled'); - теперь при добавлении
    сюда будут доступны только одно из 3х значений, иначе выдаст ошибку.
SET - можнт быть несколько, пример (удобства) facilities SET('wifi', 'ac', 'view', 'tv'); - сюда можно дабвить
    как одно, так и пустую строку '', так и несколько значений 'wifi,ac' (без пробелов). После чего можно будет
    запросто найти по запросу SELECT * FROM table WHERE FIND_IN_SET ('wifi', facilities); - покажет все варианты,
    где есть wifi. Если нужно несколько - WHERE FIND_IN_SET ('wifi', facilities) AND FIND_IN_SET ('tv', facilities);
    Покажет те варианты, где есть и wifi и tv, весьма удобно.

Обновление данных
После WHERE синтаксис такой же, как и в SELECT.. можно добавить ORDER BY & LIMIT;
Синтакс -> UPDATE название_таблицы SET столбик = 'новое_значение' WHERE столбик = 'старое значение';
Пример:
    UPDATE users SET name = 'Женько' WHERE name = 'жЕнько'; (лучше изменять по id, WHERE id = 15;)
Пример 2:
    UPDATE products SET price = price * 0.99 ORDER BY price DESC LIMIT 1; <- изменить цену в товаре, какой? - отсортируй по уменьшению цены и возьми первый.
    т.е. означает - у товара с самой большей ценой изменить цену на цена * 0.99.

UNSIGNED - пришется к INT при создани колонки... убирает минусовую часть и максимум становится в 2 раза больше
есть (TINYINT - byte, SMALLINT - short, MEDIUMINT -8.38кк +8.38кк, INT - int & BIGINT - long)
Дата сейчас - CURRENT_TIMESTAMP (можно в дефолт всунуть)
PRIMARY KEY(если их несколько, то дописать отдель primary key (id, id_2) - уникальным только оба значения, к 1 1, значения 2 1 и 1 2 не будут уникальны, только 1 1
UNIQUE KEY (какой-то параметр, еще один) в конце.. если несколько, то работает как выше.
    UNIQUE KEY (pad, pad2), UNIQUE KEY (som); - уникальность отдельно у som и у связки pad-pad2
    UNIQUE KEY mykey (pad, pad2) - можно создать ключ mykey по каким-то уникальным полям

AUTO_INCREMENT
CREATE INDEX название ON лист(столбец) = CREATE INDEX player_index ON mons(user_id)
    команда создаст индекс.. все одинаковые значения в user_id перекинутся, как бы в отдельный файл, и когда
    при поиске нужно будет искать в user_id = 240, он не будет просматривать все все записи в таблице, а сразу
    выберет этот список, где у каждого поля значение = 240 и покажет его. Многократно ++ к производительности.
    База должна обработать все записи и сформировать индексы.. это занимает на 1кк записей ~ 5с. (в теории.. при этом поиск по этому значению ускоряется в раз 6)
    ! Можно добавлять индексы и во время создания таблицы:
        Для этого в конце создания таблицы нужно указать INDEX player_index (user_id), где
        INDEX название_индекса (по_какому_полю)
    SHOW INDEXES FROM table_name
    DROP INDEX some_index_name ON (table_name)
    Так же можно создать индекс по несколько колонкам index (col1, col2)
    Для уникального ставится unique перед индексом.. уникальные служат в основм для создания нескольких значений
        к примеру номер серии и пасспорт create unique index sepass on table(series, passport);... если не
        использовать несколько значений, то это ТОЖЕ САМОЕ, что и unique key.. удалять unique key так же, как и
        индекс - drop index NAME on table; <- даже если NAME создан как unique key, а не index.. просто тоже самое.
Команды для изменения таблицы
    ALTER TABLE table_name ADD COLUMN col_name int default 1...параметры
    ALTER TABLE table_name MODIFY row_name VARCHAR(50) not null.. после названия таблицы пишется modify и имя колонки,
        после чего указывается новые параметры для колонки.
    ALTER TABLE table_name CHANGE worng_name correct_name ...
    Важно понять, что после ввода имени столбца (или сначала изначальное имся столбца, а потом новое для изменения
        самого имени столбца) - нужно так же ввести все характеристики к столбцу, полность. Если нужно поменять -
        то ввести измененные данные, а если ничего не нужно менять - все равно ввести полное "описание" и SQL
        уже сама будет решать, что менять, а что оставить.
RENAME TABLE name TO names, log TO logs;... просто

*//**       ------------      ------------      D a t a G r i d (код)      ------------      ------------      ------------      ------------                                                                         *//*
Можно все делать как через графический интерфейс, так и через код. К примеру, что бы добавить в список heroes
    какое-то поле, можно перейти в таблицу, нажать плюсик и заполнить все полня, после чего нажать Submit и готово.
Но IDL переделывает это все в строку. И если строк много - можно это все сделать через sublime, скопировав с
    консоли уже сгенерированный код и поставив свои значения. Вот что мы получили (разделил на 2 строки):
        INSERT INTO public.heroes (id, nickname, firstname, lastname, email, date)
        VALUES (3, 'someone', 'some', 'one', 'someone@gmail.com', '2020-04-24');
    Осталось изменить значение на null и скопировать сколько надо раз, и через sublime заменить все поля по очереди.

Cmd + Shift + A -> Transpose            Изменить отображение колонок
Vacuum mons;                            Оптимизация таблицы (если было много изменения и она подтормаживает или тяжелая)


*//**       ------------      ------------      Т О Ч К А   В Х О Д А      ------------      ------------      ------------      ------------                                                                         *//*

*//**       ------------      ------------      Т О Ч К А   В Х О Д А      ------------      ------------      ------------      ------------                                                                         *//*

*//**       ------------      ------------      Т О Ч К А   В Х О Д А      ------------      ------------      ------------      ------------                                                                         *//*

*//**       ------------      ------------      Т О Ч К А   В Х О Д А      ------------      ------------      ------------      ------------                                                                         *//*

*//**       ------------      ------------      P o s t g r e s S Q L      ------------      ------------      ------------      ------------                                                                         *//*
Консольно - psql для входа в постгрес. Очень важно после каждой команды её закрывать ';'.
CREATE DATABASE my_db;              создает новую базу my_db
\list                               покажет лист с базами
\connect my_db                      подключится к базе, \connect postgres - обратно
DROP DATABASE my_db;                удалить базу данных

*//**       ------------      ------------     --------      --------      ------------      ------------      ------------      ------------
*/
