/**
 * @author skul
 */

public class NotesJava {
}
/*

Комбинации быстрые:
sout            System.out.println();
fori            for (int i = 0; i < ; i++);
Cmd + D         копирование строки;
Cmd + /         ставит в начало строки //
Option + Shift  передвигается строку выше или ниже
Cmd + Shift     на метод выше / ниже
Option + Enter  решает почти все проблемы
Control + N     создать сеттеры, геттеры или что угодно
Control + O     какой метод переписать
Cmd Fn F12      покажет все методы, что есть в классе
Cmd + Shift + '-'/'+' откроет или спрячет весь код в одну строчку
Double Shift    поиск по классам
Выделить + 2хShift  поиск сразу по выделенному слову


String
.toString();                вывести на экран
.indexOf("a");              получить индекс символа "а", выдаст первый с начала строки
.charAt("3");               получить букву под номером 2 (начинает считать с 0)
.toUpperCase();
.toLowerCase();
.toCharArray();             перевод в массив char... char [] = ...
.concat();                  объеденить..
.trim() / strip()           удаляет начальные и конечные пробелы. Лучше - strip, он новее и его советует Oracle
.split("\\s");              разделяет строки там, где пробел (или можно указать другой знак). // String[] numbs = line.split(" "); (https://www.youtube.com/watch?v=j3I-jLGW8yU&list=PLAma_mKffTOSUkXp26rgdnC0PicnmnDak&index=37)
.substring();               Если вписать (5) - выводит строку с 5го символа, если (5, 10) - с 5го по 10й
.join();                    соединяет строки с учетом разделителя
.contains                   проверяет, содержит ли строка заданную последовательность символов и возвращает true или false
сompare();                  сравнивает две строки
getChars();                 возвращает группу символов
equalsIgnoreCase();         сравнивает строки без учета регистра
regionMatches();            сравнивает подстроки в строках
indexOf();                  находит индекс первого вхождения подстроки в строку
lastIndexOf();              находит индекс последнего вхождения подстроки в строку
startsWith();               определяет, начинается ли строка с подстроки
endsWith();                 определяет, заканчивается ли строка на определенную подстроку
replace();                  заменяет в строке одну подстроку на другую ("что заменить", "новое значение");
replaceAll();
Начная с 11 Java
repeat(int) - Повторяет строку столько раз, сколько int параметром int
lines() - использует Spliterator, чтобы лениво предоставлять строки из исходной строки
isBlank() - Указывает, является ли строка пустой или содержит только пробелы
stripLeading() - Удаляет stripLeading() пространство с самого начала
stripTrailing() - Удаляет stripTrailing() пространство с конца
strip() - Удаляет пустое пространство с обоих, начиная и с конца строки
----- // String заносит строку в стиминг пул и она не меняется. Если задается новое значение - это новое заносится
туда, а старое так там и остается. Лучше работают StringBuffer и StringBuilder, они в случае изменения не создают
новое значение, а изменяют существующее. StringBuffer синхронизирован (потокобезопасен) и по этому скорость работы
хромает. StringBuilder такой же, но не синхронизирован, по этому работает гораздо быстрее.
.append();                  добавить к строке, в конец
.insert();                  добавить по индексу (3, "лгпрл")
.delete();                  удалить
.charAt();                  получить индекс / символ
.setCharAt();               изменить символ по индексу
.capacity();                показывает кол-во символов, для которых Выделена память
.ensureCapacity();          меняет макс. длины выделенной памяти для символов
.getChars();                получает символы в диапазоне (Начало, Конец, Имя_массива, 0) - там где 0 - с какой ячейки вставлять
.substring();               обрезка, (3) - с 3го индекса до конца, (3, 7) - с 3го до 7го.
.length();                  длина
.setLength();               изменение, если больше - добавятся пустые строки ' ', если меньше - урежутся
.replace();                 замена, (3, 7, "новое") - с какого, по какой, что поставить
String.format
%s                          текст
    %S                      верхний регистр
%d                          цифры
%f                          дробное
    %e                      вывод в виде 3.33 -> 3,33e+00
%b                          boolean
%c                          char
%t                          Date        и еще из Oracle - Class Formatter: 'c'	Date and time formatted as "%ta %tb %td %tT %tZ %tY", e.g. "Sun Jul 20 16:17:00 EDT 1969".
    %tT                         время в часы : минуты : секунды
    %ty                         года
    %tm                         месяца
    %td                         дни
    %tH                         часы 24ч формат (%tI 12ч)
    %tM                         минуты
    %tS                         секунды
%%                          %
%n                          перенос на след. строку


Math
.max(x, y);                 макс
.min(x, y);                 мин
.sqrt(x);                   Получить корень числа
.pow(x, 2);                 Возвести x в степень 2
.abs(x);                    Сделать цифру + положительной
.random();                  Выдаст рандом от 0 до 0.99999 и т.д.
.round();                   Округление к ближайшему целому
#1: SplittableRandom random = new SplittableRandom();       |   int numb2 = random.nextInt(1, 7);   // делают то
#2:         Random random = new Random();                   |   int numb3 = random.nextInt(7);      // же самое
ВНИМАНИЕ.. про одинаковых условия, при генерации числ от 0 до 5000:
        0.4c        random.nextInt(0,5001); - статический объект SplittableRandom random = new SplittableRandom();
        1.1c        random.nextInt(5001); - созданный статический объект и ображение по ссылке Random -> random <- = new Random();
        2.2c        Math.random() * 5001
        6.5c        new Random().nextInt(5001);
SplittableRandom лучше в любом из случаев

StackTraceElement
.getClassName();        //
.getMethodName();
.getLineNumber();       // номер строки в файле
.getFileName();         // имя файла (в 1м файле может быть много классов)
.getModuleName();       // имя модуля
.getModuleVersion();    // версию модуля

*//**                                                    Ф И Ш К И                                                                                                                          *//**

    Дата    *//*
    О С Н О В Н О Е
Что есть - Data (устаревший, вместо него используют GregorianCalendar), SimpleDateFormat и
Calendar (GregorianCalendar). Редактировать время используя Calendar, а выводить = SimpleDateFormat
Нужно создать объект SimpleDateFormat и указать формат ("dd MM yyy"), после чего нужно само время, которое вывести
в таком формате. К примеру Calendar date = new GregorianCalendar(); <- если ничего не указивать будет иметь нынешнее
время и дату.

    S i m p l e D a t e F o r m a t
У SimpleDateFormat есть методы:
1. sdf.format(date.getTime());      // sdfСсылкаНаОбъект.format(ссылка_на_календарь);
2. sdf.parse(); {
String format = "09/02/1982 15:58:32";                      // Есть строка с временем
SimpleDateFormat sdf = new Sim..at("dd/MM/yyyy hh:mm:ss");  // Нужно написать в каком формате принимать
Date date = sdf.parse(format);                              // поместили в дату значение: обработанная строка в sdf
}                                   // осталось вывести date..
3. Конвертировать дату в календарь (97line)
Calendar calendar = Calendar.getInstance();
calendar.setTime(date);

    С Р А В Н Е Н И Е   Д В У Х   Д А Т  ! ! ! !
DateTimeFormatter formatter = DateTimeFormatter.patternOf("dd.MM.yyyy");    // написать формат строки

String str1 = "24.03.1997", str2 = "30.05.2000";        // пример
LocalDate date1 = LocalDate.parse(str1, formatter);     // указывается (дата, и_формат_даты)
localDate date2 = LocalDate.parse(str2, formatter);

Period period = Period.between(date2 , date1);          // вычеслит разницу, получить значения:
period.getMonths(); | period.getYears(); и т.д.

! Если находится во времени, к примеру Calendar cal = Calendar.getInst ance();
SimpleDateFormat sdf = new SimpleDateFormat("dd.MM.yyyy");
DateTimeFormatter formatter = DateTimeFormatter.patternOf("dd.MM.yyyy")
LocalDate date1 = LocalDate.parse(sdf.format(cal.getTime()), formatter); - вот так для обоих

    Р А Б О Т А   С   К А Л Е Н Д А Р Е М
GregorianCalendar nameCalendar = new GregorianCalendar();       // можно так (2020, Calendar.MARCH, 10);
.set(Calendar.YEAR, 2010);
     Calendar.MONTH, 2);            // С нуля
     Calendar.DAY_OF_MONTH, 10);    // Можно написать -10 и оно вычтет 10 дней
     Calendar.HOUR_OF_DAY, 14);
     Calendar.MINUTE, 52);
     Calendar.SECOND, 30);
.add                                // Все варианты выше будут прибавлять данные значения или отнимать.
.roll();                            // меняет одно значение без изменений других
.get();                             //
.isLeapYear(год);                   // true - если високосный, false...
.areFieldsSet;                      // были ли установлены компоненты времени
.getTime(); / .setTime();           // Для преобразования из Date в Calendar (set) и обратно (get)
.Calendar.getInstance();            // не знаю что делает..
    М А Т Е Р И А Л Ы
https://www.codeflow.site/ru/article/java__java-date-and-calendar-examples
http://proglang.su/java/date-and-time *//**

     Регулярные выражения *//*
За регулярки отвечают 2 метода: Pattern, Matcher. Паттерну мы передаем <строку с выражением>, а второму - сам паттерн.
 1. Pattern это синглтон, т.е. создание объекта возможно только внутри самого класса. Что бы он создал и присвоил нам
объект - нужно объявить ссылку Pattern pattern и вызвать метод ('=') compile( куда передается строка ). К примеру:
String line = "A.+a";
Pattern patter = Pattern.compile(line, Pattern.CASE_INSENSITIVE);   // последний - сравнивает без учета регистра
В этом примере первое - строка с самим выражением, второе - режим сравнения шаблона с текстом.

Методы (пишутся pattern.METHOD();):
 - String .pattern()                    Возвращает строку с паттерном
 - boolean .matches(pattern, words)     Первое - паттерн (A.+a), второе - по чему сверять (строка, "Анна Егор Алекса")
 - int .flags()                         Вовзращает номер режима (шаблона)
 - String[] .split(words, 10)           Разбивает текст words на массив элеметров типа String. Вторым значением -
                                            определяет предельное кол-во совпадений, что нужно искать.
                                            больше 0 - столько и скать (к примеру если  3 - искать 3)
                                            меньше 0 - искать все
                                            равно 0 - искать все, пустые строки в конце массива отбрасываются

 2. Matcher - это "поисковик", движек. Что бы работать ему нужен шаблон по которому искать (паттерн) и где искать (строка).
За создание отвечает .matcher(), куда передаются строка, где искать (послед. символов), почти любые классы. Как работает:
Matcher matcher = patter.matcher(line);

Методы (matcher.find()):
 - boolean .find()                      Если находит - true, если нет - false
 - String .group()                      Дает строку того, что нашло
 - int .start()                         С какого индекса начинаются
 - int .end()                           На каком индексе заканчиваются
 - String .replaceFirst()               Заменить только первое совпадение на ("что-то еще");
 - String .replaceAll()                 Заменить все совпадения на ("что-то еще");

Пример:
String words = "Егор Алла Анна";
Pattern pattern = Pattern.compile("A.+?");

Matcher matcher = pattern.matcher(words);
while (matcher.find()) {
    int start = matcher.start();
    int end = matcher.end();
    System.out.printf("Совпадение: %s (начало с %d до %d)", words.substring(start, end), start, end-1");
}
System.out.println(matcher.replaceFirst("На-это"));     // Егор На-это Анна
System.out.println(matcher.replaceAll("На-это"));       // Егор На-это На-это
System.out.println(words);                              // Егор Алла Анна


Синтаксис - использования знаков <([{\^-=$!|]})?*+.> вместе с символами (буквами):
    1. Метасимволы для поиска совпадений границ строк или текста
        ^	    начало строки
        $	    конец строки
        \\b	    граница слова
        \\B	    не граница слова
        \\A	    начало ввода
        \\G	    конец предыдущего совпадения
        \\Z	    конец ввода
        \\z	    конец ввода
    2. Метасимволы для поиска символьных классов
        \\d	    цифровой символ [0-9]
        \\D	    нецифровой символ [a-zA-Z]
        \\s	    символ пробела
        \\S	    непробельный символ
        \\w	    буквенно-цифровой символ или знак подчёркивания
        \\W	    любой символ, кроме буквенного, цифрового или знака подчёркивания
        .	    любой символ
    3. Метасимволы для поиска символов редактирования текста
        \t	    символ табуляции
        \n	    символ новой строки
        \r	    символ возврата каретки
        \f	    переход на новую страницу
        \u0085	символ следующей строки
        \u2028	символ разделения строк
        \u2029	символ разделения абзацев
    4. Метасимволы для группировки символов
        [абв]	любой из перечисленных (а,б, или в)
        [^абв]	любой, кроме перечисленных (не а,б, в)
        [a-zA-Z]	    слияние диапазонов (латинские символы от a до z без учета регистра )
        [a-d[m-p]]	    объединение символов (от a до d и от m до p)
        [a-z&&[def]]	пересечение символов (символы d,e,f)
        [a-z&&[^bc]]	вычитание символов (символы a, d-z)
    5. Метасимволы для обозначения количества символов – квантификаторы. Квантификатор всегда следует после символа
    или группы символов.
        ?	    один или отсутствует
        *	    ноль или более раз
        +	    один или более раз
        {n}	    n раз
        {n,}	n раз и более
        {n,m}	не менее n раз и не более m раз
    6. Ост.
        \Q...\E     Java воспринимает как "дословно", т.е. не нужно слешить (1+2=3 -> 1\\+2=3 -> \\Q1+2=3\E)
// Регулярные выражения задаются с использованем строкового литерала \, на который в Java есть своим правила. При
написании этого знака java ожидает какой-то спец-символ, он интрпритируется как символ управляющей последовательности.
Он предупреждает, что символ за ним - специальный и его нужно по другому итерпритировать. По этому тут это знак нужно
дублировать - \\ примеры (String l):
1. l = "\\s"                пробел
2. l = "\u2028"             Спец. знак
3. l = "How\\?"             How?
4. l = "\\"Welcome\\!\\""   "Welcome!" (?)
5. l = "\n"                 перево на новую строку
Есть 3 режима, их понимать сложно, но они весьма крутые, это A.+a (+), A.++a (++) и A.+?a (+?). Как работают
    A.+a    это называется жадный режим. Он ищет первую букву А, потом ищет ЛЮБОУЮ букву 1+ раз.. т.е. ищет
                пока строка не закончится.. ну ведь + значит от 1 до бексонечности) Так что строка заканчивается...
                и идет след. символ - 'a'. Он с конца ищет его, и отбрасывает заднюю часть тех букв, что не 'a'
                Egor Alla Aleksandr -> "Alla Aleksa"
    А.++а   это сверхжадный режим... он ищет А, потом до конца строки любую букву.. и все. После дохождения до
                конца он пытается выполнить след. условие -> а, но там ничего нет. Он ничего и не покажет. Получше
                примеров не нашел, сложно бе бе бе.
    А.+?а   это ленивый квантификатор. Как он работает - он находит букву А, после чего ищет любую букву.. Когда он
                находит любую букву - он начинает искать 'a'.
                Egor Alla Aleksandr -> "Alla" и "Aleksa"
                                 A -> нашел любую букву 'l' -> ищет 'a'

matcher         как бы говорит - есть ли совпадению по этому регулярному выржению в строке, вид pattern.matcher(line)
matches         соответствует

Проверки:
что-то(?=Y)         - найди (что-то), при условии, что за ним Y. Если написать несколько (?=Y)(?=C), то за (что-то) должно быть и Y и С
                        \\d+(?=€) -> Ищет число, за котороым стоит €
что-то(?!Y)         - найди (что-то), при условии, что за ним НЕТ Y
                        \\d+(?!€) - Ищет число, за которым нет €
(?<=Y)(что-то)      - найди (что-то), но перед ним должно быть Y
                        (?<=[?&]).+ - Ищет все буквы после знаков ? и &
(?<!Y)(что-то)      - найди (что-то), но перед ним НЕ должно быть Y
                        (?<![a-zA-Z\\s])\\b\\d+ - Ищет все цифры, перед которыми не идут буквы и пробел (.241 - ок)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *//**
     Тема    *//*

 *//**       ------------      ------------    П Р О Ч Е Е       ------------      ------------      ------------                                                                         *//*
main ->  System.out.println(line("Рука_", 1));
private static String line(String s, int count){                // Многократно УСКОРЯЕТ работу кода
        StringBuffer buf = new StringBuffer();                  // создали объект нашего буфера
        for (int i = 0; i < count; i++) {
            buf.append(s);                                      // использовали команду, которая добавляет
        }                                                          строку s к концу строки, имеющейся в буфере
        return buf.toString();
    }

for (int i = name.length - 1; i > 0; i--) {                     // Цикл для, меняет местами содержимое ячеек наоборт
    for (int j = 0; j < i; j++) {
        if (name[j] > name[j + 1]) {
            proc = name[j];                                     // Если числа, то int proc =...
            name[j] = name[j + 1];                              // Если текст, то String proc = ...
            name[j + 1] = proc;
        }
    }
}

public static String toString() {                               // вид для изменения toString
    return ;
}

P R O P E R T I E S - как мапа, но сохраняется в файл. Как с ним работать.
1. Создать объект Properties prop = new Properties();
ЗАПИСЬ - Для записи в файл и выгрузки из файла используются разные наборы методов:
prop.load(inputStream);        - передается файл, откуда он будет читать (или какой-то Reader)
prop.getProperty("email");     - вернет значение ключа email, если нету - null. Так же - ("email", "not found") - выдаст "not found" если ключа "email" нет
prop.stringPropertyNames;      - получить Set всех ключей for (String key : prop.stringPropertyNames()) { key = prop.getProperty(keY) }
Можно выводить или через поиск значения по ключу, или перебор всех ключей и поиск по ним, или так:
for (Map.Entry<String, String> entry : prop.entrySet()) {
    System.put.println(entry.getKey() + " = " + entry.getValue()); }
СОХРАНЕНИЕ - Для сохранения сначала нужно добавить все элементы, после чего выгрузить
prop.setPriority(key, value);       - добавляем ключ - значение или:
prop.addAll(someMap);               - добавляет все ключи - значения из мапы
prop.store(outputStream, comment);  - выгружаем, передаем outputStream или Writer, пишем коммент
*//**       ------------      ------------    М А С С И В    v.s.  A r r a y L i s t       ------------      ------------      ------------                                                                         *//*
            Массив:                                                     ArrayList
Использовать, когда мы знаем точный объем массива.          Использовать, если мы не знаем какая длина нам нужна.
                                                            Это как резиновый массив

                                        Объявления (начала там public, static если надо):

Тип_Данных[] Имя_переменной = new Тип_Данных [сколько];     ArrayList <Тип_Данных> Имя_переменной = new ArrayList<>;
String[] textArray = new String[10];                        ArrayList <String> textArray = new ArrayList<>;

В "сколько" должно быть только число типа int.              Объем не указываем, он резиновый. Вместо <String> можно быть
                                                                какой-то класс, типа <Cat> и т.д. Для простых переменных типа
                                                                int, double  нужно использовать класс-оболочку <Integer> / <Double>

                                            Как обращаться:
Длина:          textArray.length                            textArray.size();
Как положить:   textArray[0] = "Положить строку";           textArray.add("Положить строку");
                                                            textArray.add(0, "в начало добавить"); = Добавит в 0 новое значение, все остальные сдвинутся вниз
Как взять:      textArray[0] (так же)                       textArray.get(0);
Изменить:       textArray[0] = "Новая строка";              textArray.set(0, "Новая фраза");
   (т.е. тут менять так же, как и ложить,                   textArray.remove(1); или
    т.к. нельзя добавлять новый, как в ArrayList.           textArray.remove("Положить строку"); = удалять можно по строке (данной) и по индексу
Содержит:       ----                                        textArray.indexOf("Положить строку"); (еще .contains(""); - узнать под каким индексом эта строка.. будет 1 (т.е. под 0 мы поставили "в начало добавить"). Выдаст -1, если такого нет.
Очистить:       textArray = null                            textArray.clear();
Отсортировать:  Arrays.sort(textArray);                     Collections.sort(textArray); = sort - от меньшего к большему (от а до я). reverse - обратно.
Скопировать:    Arrays.copyOf(tA, tA.length);
    copyOf(tA, 4) | если написать copyOfRange(tA, 2,6)
    то будет скпировано -> (2, 3, 4, 5)
Вывести:        Arrays.toString(textArray);                 System.out.println(list);
Сравнить:       Arrays.equals(tA_1, tA_2);
Длина строки:   textArray[0].length();                      tA1.retainAll(tA2); - А в tA1 оставит лишь то, что есть в tA2, все остальное удалит. В tA2 удалит все строки, что повторяются в tA1. Пример: если в 1 есть слова "Рыба" и "Машина", а вот втором есть слова "Ноут" и "Рыба", тогда в 1м останется только "Рыба", а во втором - "Ноут".
Для копирования Двумерных массивов используется то же,      Collections.addAll(textArray, "dwed", "dwedew"); || Collections.addAll(textArray, new Cat("Po6ept"), new Cat ("Mayc9"));
что и для обычнах. А для других дел -                           Так же в ArrayList могут быть 2 одиновых значения, т.е. повторяться. И если нам нужно узнать не
Arrays.deepEqual(tA1, tA2); и Arrays.deepToString(tA);          индекс, а к примеру сколько раз фраза была введена в ArrayList, то нужно будет перебирать весь массив.







*//**       ------------      ------------      H a s h S e t   (n - name)     ------------      ------------      ------------      ------------                                                                         *//*
У HashSet'а есть свои методы. Так же Set, List & Queue могут использовать колеции. Так что помимо немногих своих
можно использовать Collections. Свои:
n.add("что-то");
n.remove("какую строку");           - выдаст true если такой элемент был
n.contains("поиск_строки");         - выдаст true / false
n.size();
n.clear();

Что бы вывести
for (String g : n) System.out.println(g); - присвой g каждый элемент по 1му, что есть в Сете.
    Длинная запись:
        Iterator<String> iterName = n.iterator();
        while (iterName.hasNext()) {
            String g = iterName.next();
            System.out.println(g);
        }
*//**       ------------      ------------      H a s h M a p   (n - name)     ------------      ------------      ------------      ------------                                                                         *//*
Методы:
n.put (key, value);                     - добавить. Если такой key уже есть, то старое value заменится на новое
n.get (key);                            - узнать value введя (key)
n.containsKey();                        - Проверяет наличие ключа (первое значение). Выдаст true/false
n.containsValue();                      - значения (второе значение). Выдаст true/false
n.remove(key);                          -
n.clear();
n.size();                               - Возвращает кол-во пар
n.isEmpty();                            - пустой ли
n.keySet();                             - Получить множество ключей
n.values();                             - Получить множество значений
n.entrySet();                           - Получить множество всех пар

Что бы вывести
Самый простой - получить key и по ниму вывести value:
    for (String gKey : n.keySet()) {
        String gValue = n.get(gKey);
        System.out.println(gKey + " - " + gValue);
    }

"Другой":
    for (Map.Entry<String, String> pair : n.entrySet()) {
        String gKey = pair.getKey();
        String gValue = pair.getValue();
        System.out.println(gKey + " - " + gValue);
    }

!! Удалять нужно или с помощью копии мапы или итератора, только они смогут правильно удалить без ошибок. Итератор:
    Iterator<Map.Entry<String, String>> iterName = map.entrySet().iterator();
    while (iterName.hasNext()) {
        Map.Entry<String, String> pair = iterName.next();
        String key = pair.getKey();
        String value = pair.getValue();
        if (pair.getValue().equals("рука")) {
            iterName.remove();
        }
    }
Так же это все можно заменить - map.entrySet().removeIf(pair -> pair.getValue().equals("рука"));   лямбды они такие


*//**       ------------      ------------      Ч Т Е Н И Е   И   З А П И С Ь      ------------      ------------      ------------      ------------                                                                         *//*
Для чтения файла и записи используются 4 класса - байтовые (InputStream OutputStream) и символьные (Reader & Writer).
    Данные записываются (передаются) в байтах, по этому, что бы было удобней - нужно потом эти данные обворачивать
    другими классами. Есть еще класс File, однако он работает непосредственно с файлами (получить информацию о файле:
    права доступа, время и дата создания), для работы с данными файла нужно использовать поток (Stream).
InputStream - запись чего-то в программу. Что бы записать нужно считать данные откуда-то, для этого используется
    методо .read()
OutputStream - выгрузка из программы (запись в файл). Используется метод .write();
Сами по себе они абстрактные, по этому новый объект нужно создавать FileInputStream или FileOutputStream
OutputStream name = new FileOutputStream("/путь/к/файлу.txt", true);       // true - добавить в конец, false - перезаписать

ОСНОВНОЕ:
    Чтение:
        1. Нужно создать InputStream - начать считывать байты.
        2. Этот "поток" обернуть символьным классом - InputStreamReader
        3. Если нужно - считыть построчно через BufferReader
        BufferedReader rd = new BufferedReader (new InputStreamReader(new FIleInputStream("/.../ways.txt")));
    Проще:
        BufferedReader rd = new BufferedReader (new FileReader("/.../ways.txt"));
    Запись.. тоже самое, что и чтение
        BufferedWriter bw = new BufferedWriter (new FileWriter("/.../path.txt"));

 ------ ------ ------ ------ ------ ------ Байтовые ------ ------
 Чтение:
 ! - BufferedInputStream
 - ByteArrayInputStream
 - DataInputStream
 ! - FileInputStream - для чтения файла в байтах
 - ObjectInputStream
 - PipedInputStream
 - FilterInputStream
 Запись:
Первые два используется для получения данных и их дальнейшего преобразования в более удобным форма. Для это есть
достаточно много классов... сначала рассмотрим менее удобный - байтовые:
 ! - BufferedOutputStream - Буферизированный выходной поток (повышения производительности)
 - ByteArrayOutputStream - Создает буфер в памяти. Все данные, посылаемые в этот поток, размещаются в созданном буфере (использует байтовый массив в выходном потоке. Метод close() можно не вызывать)
 - DataOutputStream - Выходной поток, включающий методы для записи стандартных типов данных Java
 ! - FileOutputStream - Отправка данных в файл на диске. Реализация класса OutputStream
 - ObjectOutputStream - Выходной поток для объектов
 - PipedOutputStream - Реализует понятие выходного канала.
 - FilterOutputStream - Абстрактный класс, предоставляющий интерфейс для классов-надстроек, которые добавляют к существующим потокам полезные свойства.
Их методы:
! int .available() - говорит, сколько байтов осталось в файле.. если пусто выбрасывает -1
! int .close() - закрывает выходной поток. Следующие попытки записи передадут исключение IOException
! abstract void .write (int oneByte) - записывает единственный байт в выходной поток
void .flush() - финализирует выходное состояние, очищая все буферы вывода
void .write (byte[] buffer) - записывает полный массив байтов в выходной поток
void .write (byte[] buffer, int offset, int count) - записывает диапазон из count байт из массива, начиная с смещения offset

------ ------ ------ ------ ------ ------ Символьные: ------ ------
 Символьные потоки имеют два основных абстрактных класса Reader и Writer, управляющие потоками символов Unicode.
            1. Reader:  -- Чтение из файла
! - BufferedReader - Буферизированный входной символьный поток (увеличивает производительность за счёт буферизации ввода)
 - CharArrayReader - Входной поток, который читает из символьного массива
! - FileReader - Входной поток (можно использовать для чтения содержимого файла)
 - FilterReader - Фильтрующий читатель
! - InputStreamReader - Входной поток, транслирующий байты в символы
 - LineNumberReader - Входной поток, подсчитывающий строки
 - PipedReader - Входной канал
 - PushbackReader - Входной поток, позволяющий возвращать символы обратно в поток
 - StringReader - Входной поток, читающий из строки
Их методы:
abstract void .close() - закрывает входной поток. Последующие попытки чтения передадут исключение IOException
! int .read() - возвращает целочисленное представление следующего доступного символа вызывающего входного потока. При достижении конца файла возвращает значение -1. Есть и другие перегруженные версии метода
! void .mark(int readLimit) - помещает метку в текущую позицию во входном потоке
! boolean .ready() - возвращает значение true, если следующий запрос не будет ожидать.
boolean .markSupported() - возвращает true, если поток поддерживает методы mark() и reset()
void .reset() - сбрасывает указатель ввода в ранее установленную позицию метки
logn .skip(long charCount) - пропускает указанное число символов ввода, возвращая количество действительно пропущенных символов
            2. Writer: -- Запись в файл
 - BufferedWriter - Буферизированный выходной символьный поток (можно повысить производительность за счёт снижения количества операций физической записи в выходное устройство)
 - CharArrayWriter - Выходной поток, который пишет в символьный массив (использует массив для выходного потока)
 - FileWriter - Выходной поток, пишущий в файл (Есть конструкторы, которые позволяют добавить вывод в конец файла)
 - FilterWriter - Фильтрующий писатель
 - OutputStreamWriter - Выходной поток, транслирующий байты в символы
 - PipedWriter - Выходной канал
 - PrintWriter - Выходной поток, включающий методы print() и println()
 - StringWriter - Выходной поток, пишущий в строку
Их методы:
Writer .append(char c) - добавляет символ в конец вызывающего выходного потока. Возвращает ссылку на вызывающий поток
Writer .append(CharSequence csq) - добавляет символы в конец вызывающего выходного потока. Возвращает ссылку на вызывающий поток
Writer .append(CharSequence csq, int start, int end) - добавляет диапазон символов в конец вызывающего выходного потока. Возвращает ссылку на вызывающий поток
abstract void .close() - закрывает вызывающий поток
abstract void f.lush() - финализирует выходное состояние так, что все буферы очищаются
void .write(int oneChar) - записывает единственный символ в вызывающий выходной поток. Есть и другие перегруженные версии метода

PrintStream / PrintWriter - отвечает за вывод потока на консоль.
PrintStream - Наш любимый клас... System.out.println - в Классе System есть постоянная переменная out типа PrintStream
    (т.е. это объект).. и каждый раз мы вызываем:
    System (имя класса).out (ссылка на объект типа PrintStream). println(метод в классе PrintStream)

*//**       ------------      ------------      С Е Р И А Л И З А Ц И Я      ------------      ------------      ------------      ------------                                                                         *//*
Сериализая - это сохранения данных, объектов и их полей, после чего их можно выгрузить. Очень удобно, т.к. на выходе получается уже
    готовый объект с такими же полями. Т.е. не надо ничего никому присваивать, и объект можно просто использовать.
    Основные правила:
        - Все поля объекта, которые мы используем нужно так же сериализовать (реализовать интерфейс-маркер Serializable в классе). Если это текст или простые
            переменные, то проблем не будет. Если это переменные класса (объект), то он так же должен быть сериализованным и так далее. Программа заходит
            и переводит простые переменные в байты, если это объект - заходит в него и так же переводит все в байты. И так до бесконечности. По этому, что
            бы все работало, если в классе есть объект - нужно убедиться, что он тоже имеет маркер сериализации. Или эту переменную (поле) пометить как transient.
            И тогда он Пропустит её и не будет сериализовать, тогда её значение после загрузки будет null.
        - В классе, которые будет сохранять все это дело должно быть поле private static final long serialVersionUID, что ставит "пометку", к какому "сохранению"
            относится это. Т.е. при загрузке он будет сверять эти поля, если они разные - выдаст ошибку. Без него он генерирует случайное число, которе в первое
            сохранение будет работать нормально, но в случае изменения какого-то полня - выдаст ошибку (из за способа генерации этого значения). Так что её всегда
            нужно указывать. Можно начать с 1.
        - Синглтон. Если синглтон может иметь только один экземпляр, то нужно создать метод readResolve (возвращает Object, private) без параметров и в нем
            уже прописать return Singleton.getInstance(), т.е. статический метод, что бы он возвращатся именно этот один объект. Или же, если их несколько, то
            по какому-то полю определить отличия и сравнить через if, если это тот объект - присвоить его из класса. Если нет - проверить на следующий. Пример
            на сайте skipy ru в конце.
        - Пеменные static пренадлежат Классу, а не объету, по этому их сериализовать нет смысла.
        - Если есть поля Final, то использовать нужно как раз Serializable, Externalizable не сработает. Для Externalizable у класса должен быть публичный
            конструктор, так же у всех классов наследников должны быть публичные конструкторы.


    Как использовать: сначала нужно создать класс, где будут находится все данные которые нужно сохранить. К примеру SaveGame (тут должно быть поле
    private static final long serialVersionUID с номером, и массив объектов, что нас интересуют.. те же объекты могут иметь свои объекты, но они все
    должны реализовывать Serializable). После чего, в нашем главном методе:
    SaveGame same = new SaveGame(сюда передать все, для сохранения);
    FileOutputStream fos = new FileOutputStream(file);
    ObjectOutputStream oos = new ObjectOutputStream(fos);
    oos.writeObject(save);                                      - в файл запишется объект в виде байтов, если все ок.

    Что бы выгрузить:
    FileInputStream fis = new FileInputStream(file);
    ObjectInputStream ois = new ObjectInputStream(fis);
    Object object = ois.readObject();
    Save someSave = (Save) object;                              - тут и будет находится наш сохраненный объект save класса SaveGame

private void writeObject(java.io.ObjectOutputStream out) throws IOException {}
private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException {}
private static final long serialVersionUID
хорошая статья - https://javarush.ru/groups/posts/2022-serializacija-i-deserializacija-v-java
полное описание - http://www.skipy.ru/technics/serialization.html
видосики - https://www.youtube.com/watch?v=8accK8dHaa4&list=PLyxk-1FCKqodhV1d55ZmoAcz6aeyhLxnr&index=9
*//**       ------------      ------------      P a t h  /  P a t h s  /  F i l e  /  F i l e s      ------------      ------------      ------------      ------------                                                                         *//*
    File - старый доисторический динозавр, что очень неудобен (все смешено в кучу). Его решили разделить на интерфейс Path и классы Paths / Files.

    Path    переработанный аналог File. Все улитные методы перенесены в Files, упорядочены методы и возвращающие типы. Про File забыть, работать с Path
                Методы:                          (возвращают или Path, или boolean, пример "C:\Users\Username\Desktop\testFile.txt")
                   Path getFileName()   testFile.txt                — возвращает имя файла из пути.
                   Path getParent()     C:\Users\Username\Desktop   — возвращает «родительскую» директорию по отношению к текущему пути (то есть ту директорию,
                                                                        которая находится выше по дереву каталогов).
                   Path getRoot()       C:\                         — возвращает «корневую» директорию; то есть ту, которая находится на вершине дерева каталогов.
                   Bool startsWith(), endsWith()    — проверяют, начинается/заканчивается ли путь с переданного пути. Принимает текстовую строку, которорую
                                                     преобразовывает в Path. Таким образом на "Desktop\testFile.txt" даст true, а на "estFile.txt" false
                   Bool isAbsolute()                — возвращает true, если текущий путь является абсолютным:
                   Path normalize()                 - «нормализует» текущий путь, удаляя из него ненужные элементы, типо с C:\User\..\example делает без точек
                   Path relativize()                - вычисляет относительный путь между текущим и переданным путем.
    Paths   класс, что имеет один метод - get, на выходе дает экземпляр класса Path. Больше у него нет других методов.
    Files   сюда вынесены улитные статические методы, как Arrays / Collections. Он сосредоточен на управлении файлами и директориями. Используя статические
                методы Files, мы можем создавать, удалять и перемещать файлы и директории. Методы:
                   Path createFile()
                   Path createDirectory()
                   Path move(File f1, File f2, REPLACE_EXISTING)        f1 - откуда/что, f2 - куда, вместе с названием файла, окончанием
                   void delete()
                   Bool exist()
                   Path copy(File f1, File f2, REPLACE_EXISTING)        f1 - откуда/что, f2 - куда, вместе с названием файла, окончанием
                        write()                 запись
                        read()                  чтение
                 Byte[] readAllBytes()          очевидно
                 List[] readAllLines()          О да
                   Path walkFileTree()          Обход всех файлов на пк с поиском по чему-то. Аргументы - путь и FileVisitor (логика обхода).
                 Stream lines()                 возвращает Stream API, можно делать такие штуки, как ниже
Лямбдо-пример
        Stream<String> stream = Files.lines(Paths.get("C:\\Users\\Username\\Desktop\\pushkin.txt"));
        List<String> result = stream
                .filter(line -> line.startsWith("Как"))
                .map(String::toUpperCase)
                .collect(Collectors.toList());
        result.forEach(System.out::println);

*//**   -----------      ------------      ------------      ------------      ------------      ------------      ------------      ------------                                                                        *//*
ArithmeticException - арифметическая ошибка, например, деление на нуль
ArrayIndexOutOfBoundsException - выход индекса за границу массива
ArrayStoreException - присваивание элементу массива объекта несовместимого типа
ClassCastException - неверное приведение
EnumConstantNotPresentException - попытка использования неопределённого значения перечисления
IllegalArgumentException - неверный аргумент при вызове метода
IllegalMonitorStateException - неверная операция мониторинга
IllegalStateException - некорректное состояние приложения
IllegalThreadStateException - запрашиваемая операция несовместима с текущим потоком
IndexOutofBoundsException - тип индекса вышел за допустимые пределы
NegativeArraySizeException - создан массив отрицательного размера
NullPointerException - неверное использование пустой ссылки
NumberFormatException - неверное преобразование строки в числовой формат
SecurityException - попытка нарушения безопасности
StringIndexOutOfBounds - попытка использования индекса за пределами строки
TypeNotPresentException - тип не найден
UnsupportedOperationException - обнаружена неподдерживаемая операция


Список проверяемых системных исключений, которые можно включать в список throws.
ClassNotFoundException - класс не найден
CloneNotSupportedException - попытка клонировать объект, который не реализует интерфейс Cloneable
IllegalAccessException - запрещен доступ к классу
InstantiationException - попытка создать объект абстрактного класса или интерфейса
InterruptedException - поток прерван другим потоком
NoSuchFieldException - запрашиваемое поле не существует
NoSuchMethodException - запрашиваемый метод не существует
ReflectiveOperationException - исключение, связанное с рефлексией








Comparable<Object> & Comparator<Object>     <- это 2 интерфера, и able и ator являются интерфейсами.. да да да.
При реализации нужно дописать какой тип мы будем сравнивать Monster implements Comparable<Monster>   <- вот это
ВНИМАНИЕ! - весьма серьезные проблемы могут быть при сравнении Float / Double, особенно, когда появляются всякие NaN, так что в этом случае НЕОБХОДИМО использовать
        уже готовые методы в соответствутющих классах - Float.compare/Double.compare. Пример ниже..
Comparable - имеет метод compareTo с одним аргументом, его нужно, как минимум, реализовывать во всех классах, объекты которых будут помещаться в TreeSet (т.к. там
             элементы размещаются в отсортированном виде, то без этой реализации java не сможет понять как сортировать данные объекты и выдаст ошибку на этапе
             компиляции). В чем суть - он возвращает -1, 0 и 1. +1 -- первый больше, 0 -- одинаковые -1 -- первый меньше. Для обычной сортировки. Пример:
             public int compareTo (Monster monster) { return Integer.compare(this.speed, monster.speed); } - что передавать - указываем мы, вызывать вот так
             object1.compareTo(object2); Для необычной - Comparator:
Comparator - имеет метод compare с 2мя аргуметами, возвращает int. Принимает 2 аргумента, тип ставится уже во время реализации. Так же нужно указывать тип:
             Comparator<Monster>. public int compare(Monster mon1, Monster mon2) {  return  Integer.compare(mon1.speed, mon2.speed);  } по сути тоже самое, что и
             первое.
Отличия    - "Принципиальное различие в том, что в Comparable "зашит" один-единственный алгоритм сравнения объектов, в то время как Comparator представляет собой
             внешнюю заменяемую настройку. Архитектурно, Comparable - это интерфейс значения, в то время как Comparator - настройка контейнера.
             Следует использовать Comparable в том случае, когда задается естественный (наиболее логичный) порядок. Например, для строк это регистрозависимое
             лексикографическое сравнение, а для длинных чисел - сравнение по значению. Во всех остальных случаях - без отдельного компаратора не обойтись."
Больше -> https://ru.stackoverflow.com/questions/639143/В-чем-разница-между-comparable-и-comparator/639148
Наконец-то я понял. Первый - меняет логику сравнения для всего класса - если её поменять, то при обычном сравнении он всегда будет сравнивать именно так,
    как там прописано. Мы его прописывает в сам класс. Но что, если нам нужно сравнить только один / два раза как-то по особенному? Менять основную логику,
    сравнивать, а потом ставить все обратно? Нет... для это и используется Comparator. Создается новый класс, которые реализует Comparator<OurClass>, после
    чего он добавляется куда-то и просиходит сравнение.. к примеру - Collections.sort(list, AnyName); AnyName - это класс, что реализует компаратор и где
    прописана логика именно для нашего случая. Проще - можно туда встравить анонимный класс Collections.sort(list, (x1, x2) -> x2 - x1); .. хотя в классе
    Comparator уже есть готовая заготовка для обратно сортировки - Comparator.reverseOrder();
        Так же, Comparator можно использовать, даже когда класс не реализует Comparable. К примеру у нас есть чужая бибилиотека и там НЕТ сортировки, но нам
        нужно её отсортировать.. что делать? Класс менять нельзя.. Вот и он - компаратор, мы у нас прописываем логику и он сравнивает, как мы хочем.

Iterator<SomeClass>     используется при переборе коллекции. Методы hasNext() - возвращает true, если есть след. эллемент. Так же next() - берет следующий
                            элемент (если нету - выбрасыет исключение, но у нас есть hasNext, так что не проблема) и remove() - удаляет
Разные функциональные интерфейсы:
Predicate<T>                Принимает 1 параметр, возвращается Boolean.. когда надо что-то проверить и получить true/false
Consumer<T>                 Принимает 1 параметр, ничего не возвращает.. когда надо что-то просто сделать - sout
Function<T, R>              Принимает 1 параметр, возвращает какой-то второй.. т.е. <Integer, String> - принимает число, возвращает String... можно написать x -> String.valueOf(x); и
                                вернет строку из числа x
Supplier<T>                 Ничего не принимает (), возвращает T тип.. Supplier<Double>, () -> Math.random(); типа такого
UnaryOperator<T>            Принимает 1 параметр, возвращает этот 1 параметр, x -> x * x;
BinaryOperator<T>           Принимает 2 параметра, возвращает один.. (x, y) -> Math.pow(x, y);
их много.. и лучше скорее всего, что написать свой функц. интерфейс и использовать его.. а то учить все это пздц.
*//**       ------------      ------------      S t r e a m      ------------      ------------      ------------      ------------                                                                         *//*
Стрим проходит полностью по 1 элементу, потом берет второй, третий и т.д.       Не правильно - все элементы по 1 фильту, потом все по второму, потом все вывод
Если создавать именно Stream(), то его можно использовать отлько 1 раз и потом он закроется. Если нужно использовать много раз, то нужно
    использовать Supplier<Stream<String>> sup = () -> stream; и скорее всего его нужно потом закрыть
Stream<T> of()	            Создает поток из набора объектов
Stream<T> generate()	    Генерирует поток по заданному правилу
Stream<T> concat()	        Объединяет вместе несколько потоков
Stream<T> filter()	        Фильтрует данные: пропускает только данные, которые соответствуют заданному правилу
Stream<T> distinct()	    Удаляет дубликаты: не пропускает данные, которые уже были
Stream<T> sorted()	        Сортирует данные
Stream<T> peek()	        интерфейс producer.. принимает данные, но ничего не возвращает и ничего не делает (если мы не напишем какое-то действие). В осном введен для того,
                                что бы можно было продебажить какие данные проходят через стрим
Stream<T> limit(n)	        Обрезает данные после достижения лимита (создает поток из первых n элементов)
Stream<T> skip(n)	        Пропускает первые n данных              (создает поток из всех, кроме первых n эл.)
Stream<R> map()	            Преобразовывает данные из одного типа в другой  | к примеру toUpperCase(). Но не только. Еще, когда у объект нужно получить какое-то
                                поле (другой тип данных) и с ним работать. К примеру p -> p.getListOfFriends. Был тип - People, а стал теперь - лист, и мы с ним
                                можем дальше работать и выплнять какие-то функции.
Stream<R>flatMap()	        Преобразовывает данные из одного типа в другой
Stream.mapToInt()           Преобразовывает Integer к примитиву int (16 vs 4 bytes), что ускоряет после работу.. тоже самое для Double и Long
.reduce()                   принимает  лямбда-выражение известное как аккумулятор (Accumulator), которое служит для сворачивания данных в одну "кучу"
                                .reduce(Math::max).get() получение максимума
                                .reduce((left, right) -> left + right).ifPresent(System.out::println) сумировать все числа и вывести (or get to get)
boolean anyMatch()	        Проверяет, что среди данных потока есть хоть одно, которое соответствует заданному правилу
boolean allMatch()	        Проверяет, что все данные в потоке соответствуют заданному правилу
boolean noneMatch()	        Проверяет, что никакие данные в потоке не соответствуют заданному правилу
Optional<T> findFirst()	    Возвращает первый найденный элемент, который соответствует правилу
Optional<T> findAny()	    Возвращает любой элемент из потока, который соответствует правилу
Optional<T> min()	        Ищет минимальный элемент в потоке данных
Optional<T> max()	        Возвращает максимальный элемент в потоке данных
    После всех Optional нужно проверять на .isPresent() и только потом .get();, что бы не было ошибок || .orElse(), .orElseGet(), orElseThrow()
long count()	            Возвращает количество элементов в потоке данных
R collect()	                Вычитывает все данные из потока и возвращает их в виде коллекции
    Что бы использовать, нужно написать stream(). ... .collect(Collectors.toMap());
        toList()    -   Объект, который преобразует поток в список — List<T>
        toSet()     -   Объект, который преобразует поток в список — Set<T>
        toMap()     -   Объект, который преобразует поток в список — Map<K, V>
        joining()   -   Склеивает элементы потока в одну строку
        mapping()   -   Преобразует элементы потока в Map<K, V>
        groupingBy()-   Группирует элементы, возвращает Map <K, V>
                Map<String, String> result = list.stream()
                        .map( e -> e.split("=") )
                        .filter( e -> e.length == 2 )
                        .collect( Collectors.toMap(e -> e[0], e -> e[1]) );
Если ленивые операциии и не ленивые. Ленивые - это все, что нужно сделать с данными. Не ленивые - это что-то получить, вернуть, вывести и т.д. Суть в том, что пока
    не нужно получать данные, нет какой-то реализации, то все все операции по измненению / получению данных не будут выполнены. Они выполняются только тогда, когда
    написано, что нужно что-то вернуть. Пример: мы пишем фильтр, прочие изменения и все - стрим не будет выполнен.. другой пример - мы пишем фильтр, изменения и
    выполняем .get (получить) или .foreach (выполнять для каждого) - вот тут он все выполнит и даст результат.
Как их разлечать - любой метод в стриме, которые возвращает Stream - это промежуточный (lazy). Любой метод, что что-то возвращает что-то еще - это не терминальный,
    т.е. не ленивый. Когда мы используем не ленивый (терминальный) метод, дальше стрим уже использовать нельзя, нужен новый стрим (они одноразовые, данные прошли и
    все, стрим закрылся).
Тернарные:
    итерация:   forEach, iterator
    поиск:      findFirst, findAny
    проверка:   allMatch, anyMatch, noneMatch
    агрегаторы: reduction, collectors
Дополнительные методы:
    unordered - он говорит, что если стрим был упорядочен, то считай, что он теперь не упорядочен (упрощает jave работу и повышает немного производительность). При
        этом он не мешает (не shuffle).
    parallel - последняя обработка будет делать в несколько потоков
    sequential - говорит, что делать нужно в одном потоке
    Кроме того, как я понял, parallel и sequential относятся к последней операции. Так что их можно строить цепочками и менять эти свойства. Т.е. эту часть параллельно,
        другую часть - в однопотоке, потом снова параллельно и т.д.

Всякие примеры:
- List<Integer> list = IntStream.range(500, 600) -.boxed().collect(Collectors.toList()); -.toArray();
- Map<Integer, Integer> map = IntStream.range(500, 600)   // не знаю что и как делает...
                .boxed()                                // но типо так можно
                .collect(Collectors.toConcurrentMap(k -> k % 42, v -> v, (a, b) -> b));
- Есть массив или коллекция, и нужно разделить по разделителю, к примеру String[] arr = {"a", "b", "c"};
Arrays.stream(a).collect(Collectors.joining(",");   // супер че.. можно sout или возвращает тот же тип, которого массив. Т.е. сейчас - > строку String (не массив)

Java streams лучшие примеры. Взято из https://habr.com/ru/post/337350/ && https://marcin-chwedczuk.github.io/java-streams-best-practices

Суть - стримы при неправильном использовании делают код длинее и менее читабельным. Стримы нужно тогда, когда есть какое-то промежуточное
    действие, которое нужно сделать с данными. В других случах они бесполезные. Ссылка - https://habr.com/ru/post/337350/
1. forEach. Суть - не использовать стримы когда они не нужны и усложняют код:
coll.forEach()                  <-  coll.stream().forEach()
        - вывод короче
new HashSet<>(call)             <-  coll.stream().collect(toSet()) или coll.stream().collect(toCollection(TreeSet::new))
        - аналогично
coll.toArrays(new String[0])    <-  coll.stream().toArray(String[]::new)
        - нет необходимости в стриме
Collections.max(coll)           <-  coll.stream().max(Comparator.naturalOrder()).get()
        - нужно учитывать, что коллекция не null. Если может быть null, то лучше использовать стрим с max(comparator).orElse(null)
2. Порядок элемента
stream.anyMatch(условие)        <- stream.filter(условие).findFirst().isPresent()
        - Проверка на наличие элемента с какими-то параметрами
            P.s.: условие - condition, интерфейс Predicate (принимает 1 параметр, возвращает true / false).
stream.noneMatch(условие)       <- !stream.allMatch(условие), или же, если отрицание:   stream.allMatch(x -> condition(x)) вместо !stream.anyMatch(x -> !condition(x))
        - Есть / Нету элемент в коллекции.. определенно ясно, что фильтр - не оч, но с all / any тоже можно много чего делать
stream.anyMatch(condition)      <- stream.map(condition).anyMatch(b -> b) | Здесь же вариации на тему вроде stream.map(condition).noneMatch(Boolean::booleanValue) или stream.map(condition).allMatch(Boolean.TRUE::equals).
        - Не понимаю что это...
3. Создание стрима
Stream.empty()                  <- Collections.emptyList().stream()
        - когда нужен пустой стрим, что для emptyList, что для emptySet
Stream.of()                     <- Collections.singleton(x).stream()
        - для 1го элемента.. но во втором варианте явно можно указать только 1 элемент, тогда как в of - не сколько..
Arrays.stream(array)            <- Arrays.asList(array).stream()
        - когда нужен стрим для массива.. ps для создание стрима с элементов используется Stream.of()
Arrays.stream(array, from, to)  <-  IntStream.range(from, to).mapToObj(idx -> array[idx])
        - когда нужен кусочек массива, просто перегруженный метод)
        сюда же Arrays.stream(strings).map(String::trim)    <-   IntStream.range(0, strings.length).mapToObj(idx -> strings[idx].trim())
4. Коллекторы
    непонятная тема для меня сейчас, так что смотреть по ссылке
5. Не считать, то не нужно
listOfLists.stream().mapToInt(List::size).sum()     <- listOfLists.stream().flatMap(List::stream).count()
        - тут мы использует уже известный размер size и получаем сумму, вместо стого, что бы считать элементы в коллекции.. походу так
            так же можно использовать mapToLong вместо mapToInt, если числа большие
6. Другое
stream.min(comparator)          <- stream.sorted(comparator).findFirst()
        - тоже самое, но тут берется 1й элемент, а там сортируется 1 2 3 и берется первый, т.е. минимальный
            сюда же stream.max(comparator)    <-        stream.sorted(comparator.reversed()).findFirst()
stream.peek(counter::addAndGet) <- stream.map(x -> {counter.addAndGet(x);return x;})
        - тут мы хотим что-то сделать с элементом и пойти дальше, добавить куда-то и выполнять дальше действия
Дополнительно правильное использование - https://marcin-chwedczuk.github.io/java-streams-best-practices




*//**       ------------      ------------      C o n c u r r e n t      ------------      ------------      ------------      ------------                                                                         *//*
Concurrent - параллельный. Можно разделить на такие "подклассы" - Synchronized, Lock, Atomic, Executor, Collections & Queues

--  -> Executor - это интерфейс. Вообще, созданн класс для упрощения работы с тредами и их управления. Главные "ребята":
    https://javarush.ru/groups/posts/2078-threadom-java-ne-isportishjh--chastjh-v---executor-threadpool-fork-join-pool
Executor                    просто интерфейс, основа
ExecutorService             интерфейс, он используется для создания тасков и их управления. Точнее сюда кладут разные его реализации.. как с листом
ThreadPoolGroup             класс, что реализует ExecutorService. В нем реализация, но для удобство все равно юзают ExecutorService..
ScheduledExecutorService    это как ExecutorService, но для выполенения работы через какое-то время.. или каждые n-минут/секунд..
Executors                   вспомагательный класс, через него просто создавать объект ThreadPoolGroup и класть в ExecutorService для дальнейшей работы
    Стоит помнить, что Thread & Runnable - самые основы и помимо них есть Callable с Future. Они дженерики. Callable (call), как Runnable (run), но возвращает
    результат. А Future - интерфейс, его реализация -> FutureTask. Кроме того, FutureTask еще и наследуется от Runnable. "Ручной алгоритм" - создать реализацию
    Callable, создать FutureTask передав в аргументах callable и потом создать Thread передав в аргументах futureTask, запустить. Получить можно будет по
    futureTask.get(); Тут еще, кстате, есть CompletableFuture, позволяет комбинировать разные вызовы.. Все это хорошо, но...
Что бы не создавать Callable, FutureTask и Thread можно написать реализацию Runnable || Callable и просто напросто передать это в ExecutorService, в котором по
    факту будет находится ThreadPoolGroup. После создания нужно -> добавить задачи, завершить добавление - готово. И оно само начнет выполнять все эти задачи.
    Не нужно каждый раз создавать новый тред и запускать задачу:
        Runnable r = () -> System.out.println("Prosto");
        ExecutorService es = Executors.newFixedThreadPool(5);       // вернет ThreadPoolGroup с 5ю рабочими и ожидающими задачу нитями внутри
        fori es.execute(r);         // - писать в цикле, добавляем задачи и оно сразу начинает его выполянть
        es.shotDown();          // обязательно нужно выключить. Этот метод завершит прием задач, и когда все задачи закончатся - он "выключится". Если же этого
                                        не сделать, то даже если main и закончится, программа все равно будет работать. По этому важно его закрывать. Если же
                                        закрыть его, но потом поробовать добавить новую задачу - вылетит исключение RejectedExecutionException
        Важно -> execute - выполнить, submit - тоже выполнить, возвращает Future.
Запланированные задачи это -> ScheduledExecutorService. Для запланированных задач у Executors есть разные методы, например newScheduledThreadPool, при этом
    вызывать надо у объекта scheduledExecutorService.schedule, где передается задача, время и единица измерения (callable, 2, TimeUnit.MINUTES); Он выполнит задачу
    через 2 минуты. Есть разные методы, например scheduleAtFixedRate -> schedule(task, 1, 2, TimeUnit.SECONDS); (задача, через колько начать, перерывы между задачми, в чем считать)
    и другие.

--  -> Synchronized - группа, которая необходима для синхронизации тредов. В ней можно словить все треды и пускать только вместе, пропускать столько тредов, сколько
    допустимо за раз, обмениваться каким-то значением и другое.
Semaphore                   класс, который разрешает за раз проходить только определенному кол-ву тредов. К примеру можно поставить ограничение на 3 треда, и
                              тогда первые 3 войдут без проблем, а 4му придется ждать, пока кто-то выйдет. Т.е. за раз могут работать только ограниченное
                              число тредов. Метод acquire - получить разрешение, release - отдать (т.е. выйти "из блока"). Есть 2 конструктора, int и int, boolean.
                              11 - макс. число тредов за раз, 2й - макс число и флаг на сколько справедливо. Если true - треды будут проходить в порядке очереди.
CountDownLatch              класс, работает как счетчик с обратным отсчетом. Выставляем значение - 3, и он будет ловить и ждать 3 потока. Как только первые к нему
                              подходят - они блочатся и ждут, пока CountDownLatch не будет равен 0. Как только приходит 3й - он их всех отпускает и они идут дальше.
                              Один конструток, принимает число. Методы - countDown(), await(), уменьшить на 1 счетчик и ждать.. Работает только один раз, для несколько раз
                              есть CyclicBarrier
CyclicBarrier (барьер)      делает тоже самое, что и предыдущий, с одним отличием - его можно перезапустить и он будет снова работать со своего прежнего значения.
                              Какие методы есть: await() - ждет и сразу уменьшает значение на 1, isBroken() - говорит, был сломан или нет и reset() - сбрасыват лимит
                              до изначального. Имеет 2 конструктора, 1 - обычный, 2й - вторым значением дается Runnable, что будет защуен сразу после того, как барьер
                              сломан (сначала выполняетя действие, потом треды отпускаются).
Exchanger ex                класс, который служит для обмена чего-то, дженерик. Создается экземпляр, без параметров, в нити вызывается метод exchange(что_передать) и
                              она ждет, пока до обмена дойдет другая нить, у которой так же вызывается обмен. Метод exchange - в аргементах передает то, что нужно передать,
                              а он сам - возвращает эти объекты (передача). Потому нужно писать int a = ex.exchange(5); - что бы передать 5 и сразу присвоить другое значение.
                              Так же можно передать null, для передачи только в одну сторону.
Phaser                      как CyclicBarrier, но более гибкий. У него есть фазы, и треды выполняя задачи приходят в какой-то фазе, там все собираются, и когда собрались -
                              двигаются дальше к следующей фазе. У фаз есть номер, точное число тредов, которых нужно ждать - не указано. Не обязательно все треды обязаны
                              ждать.. в общем мутная темка.

--  -> Queues   -   в основном это BlockingQueue. Вся суть интерфейса в том, что берать элемент, а очередь пустая - поток засыпает. Если же пытаться положить, а очередь
    полная - поток засыпает. Во всех остальных случаях работает так же, как и обычная. BlockingQueue наследуется от Queue и имеет разные реализации, которые работают
    по разному. Хорошее описание http://java-online.ru/concurrent-queue-block.xhtml
    Методы:
        - boolean add                   Добавить. Вернет true если ок и кинет исключение, если очередь полная (лучше не использовать, IllegalStateException)
        - boolean contains              содержит ли
        - boolean offer                 Как add, но возвращает true или false.. еще есть offer(E, long, TimeUnit) - будет ждать какое-то время что бы положить и потом пойдет дальше
        - boolean remove                удалить
        - int remainingCapacity         сколько места
        - void put                      (!) Кладет объект.. или ждет, если очередь полная
        - T take                        (!) Забирает объект или ждет, если очередь пустая или не доступен
        - E poll (long, timeUnit)       чтение и удаление в течении какого-то времени
Если паредается null - бросает исключение. При этом, если метод poll не получил элемент в течении времени - он возвращает null.
Таблица
	        Вызывает Exception (не оч)	    Чтение значения (даст true/false/null)	    Блокировка (будет ждать)	        Чтение с задержкой
Insert	            add(e)	                            offer(e)	                        put(e)	                        offer(e, time, unit)
Remove	            remove()	                        poll()	                            take()	                        poll(time, unit)
Проверка	        element()	                        peek()	                            не применимый	                не применимый

Реализующие классы:
 - ArrayBlockingQueue       на основе массива
 - LinkedBlockingQueue      на основе списка (мне этот больше нравится, смысл копировать массив каждый раз). Если создавать без уточнения размера, по умолчанию - макс инт

У соединенных на узлах очереди обычно более высокая пропускная способность, чем у основанной на массиве очереди, но менее предсказуемая производительность в большинстве многопоточных приложений.






*//**       ------------      ------------      A p a c h e    U t i l s      ------------      ------------      ------------      ------------                                                                         *//*
Apache Commons IO
    IOUtils             - работы с потоками ввода и вывода
    IOCase              – Предоставляет метод для работы со строками и сравнения.
    FileUtils           - операции с файлами (открытие, чтение, копирование и перемещение)
    FilenameUtils       - независимый от операционной системы способ выполнения общих функций для имен файлов
    FileSystemUtils     - проверка свободного места на данном томе или диске
    Comparator          - пакет,
            PathFileComparator -  может использоваться для сортировки списков или массивов файлов по их пути либо с учетом регистра,
                без учета регистра или с учетом регистра
            SizeFileComparator - используется для сравнения размеров (длин) двух файлов
Apache Commons Lang
    StringUtils         - безопасная работа со строками, даже если там null
        isAllLowerCase - ergreg
        isAllUpperCase - URGRE
        isMixedCase    - neEF
        isAlpha        - ergre Unicode characters
        isAlphanumeric - v35t3
    ArrayUtils
        add(arr, "value")           - вернет массив с +1 элементом "value" в конце
        add(arr, 0, "value")        - в указанный индекс
        addAll(arr, "a", "b")       - сразу несколько значений в конец
        remove(arr, 1)              - вернет массив без элемента под индеком 1
        removeAll(arr, 1, 4)        - ну понятно...
        removeElement(arr, element)
        removeAllOccurences(arr, "v")    возвращает массив без всех v, т.е. удаляет все v
        contains
        reverse                     - да да, меняет местами
        shift(arr, 10)              - смещает 10раз вперед все элементы
        toString(arr, "YAHOO")      - выведет arr, если null - строку YAHOO
        toMap(arr)                  - переводит в мапу двомерный массив, где по 1му элементу
        isSameLength(arr1, ary2)    - проверяет длину массивов
    NumberUtils
        compare
        createNumber        - создае число из строки
        min && max          - работат с М А С С И В А М И!! -> int min = NumberUtils.min(arr);
    Fraction        - правильно работает с дробями..
    SystemUtils     - информация про Java или ОП..
        getJavaHome || getUserHome  - возврашает File тип с путем
    ConstructorUtils        - рефлексия
    FieldUtils              - рефлексивное чтение/запись, поля класса
    MethodUtils


*/